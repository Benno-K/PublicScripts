#!/usr/bin/env bash
##
# Author: Benno K.
# Email: benno@xyz.de
# Github: https://www.github.com/Benno-K
#
# This script is available for
# public use under GPL V3 (see
# file LICENSE)
#
# rbackup - Automated Rsync-based System Backup Utility
#
# This script creates a full backup of the root filesystem to another partition labeled 'rootfs' (other than the current root).
# It checks for sufficient space, supports interactive and batch/cron modes, and enforces manual approval of options for safety.
# It uses rsync with safe defaults and logs all actions. Useful for SD card or disk cloning on Linux systems.
##

set -euo pipefail

progNam=$(basename "$0")
logFil="/var/log/${progNam}.log"
tmpMntBase="/mnt/${progNam}"
# CAUTION: ${HOME} is bad as root's home is on
#          the root-fs /. Therefore approvals
#          can differ when backup root is
#          booted which can cause unwantingly
#          overwriting the source.
#          Ideas to prevent this:
#             a) store elsewhere
#             b) delete permission files on
#                target
#             c) do exclude permission files
#                from rsync (the better b)
# I testwise implemented c), tests needed
paramDir="${HOME}"
rsyncOpts=(-aHAXx --numeric-ids --delete --partial)
#rsyncExcl=(--exclude=/tmp --exclude=/var/tmp)
rsyncExcl=(
  --exclude=/tmp
  --exclude=/var/tmp
  --exclude='**/.rbackup.*-??.*-??.?.params'
)


# Print message to stderr
echO() {
	echo >&2 "$@"
}

# Log a message with a timestamp to the log file
log() {
	local msg="$@"
	local now; now="$(date --iso-8601=seconds)"
	printf '%s %s\n' "$now" "$msg" >>"$logFil" || true
}

# Print error, log it, and exit
die() {
	log "ERROR: $1"
	echO "ERROR: $1"
	exit 1
}

# Show usage/help message, optionally with an error message
showHelp() {
	cat <<-EOF
	Usage: $progNam [--dry-run] [-h|--help] [--] [...]

	Options:
	  --dry-run   Perform trial run (no data copied)
	  -h, --help  Show this help text
	  --          All following options will be appended to
	              the rsync command
	EOF
	[ -n "${1:-}" ] && echO -e "\nError: $1"
}

# Check if the target device has enough capacity (with a safety margin) for the backup
checkTargetCapacity() {
    local srcDir="/"
    local trgDev="$1"   # e.g. /dev/mmcblk0p2
    local slackPct=10   # safety margin in percent

    # Get used bytes of the source filesystem
    local srcUsed
    srcUsed=$(df --output=used -B1 "$srcDir" | tail -1)

    # Get total size of the target device in bytes
    local trgSize
    trgSize=$(blockdev --getsize64 "$trgDev")

    # Calculate required space with slack
    local need=$(( srcUsed + (srcUsed * slackPct / 100) ))

    log "Source used: $srcUsed bytes (+${slackPct}% slack = $need)"
    log "Target size: $trgSize bytes"

    if (( need > trgSize )); then
        echO "ERROR: Source ($srcUsed bytes) + slack ($need bytes) exceeds target ($trgSize bytes)"
        return 1
    fi
    return 0
}

# Get the PARTUUID of the current root filesystem
getSrcUuid() {
	local dev; dev="$(findmnt -n -o SOURCE / || true)"
	[ -n "$dev" ] || die "Cannot determine source device"
	local pu; pu="$(blkid -s PARTUUID -o value "$dev" 2>/dev/null || true)"
	[ -n "$pu" ] || die "Source device $dev has no PARTUUID"
	printf '%s' "$pu"
}

# Find the PARTUUID of a 'rootfs'-labeled partition that is NOT the current root
getTrgUuid() {
	local srcUuid="$1"
	mapfile -t list < <(blkid -t LABEL=rootfs -o export 2>/dev/null | awk -F= '/^PARTUUID=/{print $2}')
	[ "${#list[@]}" -gt 0 ] || die "No partitions with LABEL=rootfs found"
	for pu in "${list[@]}"; do
		[ "$pu" != "$srcUuid" ] && { printf '%s' "$pu"; return; }
	done
	die "No target rootfs different from source"
}

# Get device information for display/logging
getDevInfo() {
	local dev="${1/\/dev\//}"
	local bus model vendor serial devKind

	# Try to get info from udevadm
	read bus model vendor serial < <(
		udevadm info --query=property --name="$dev" 2>/dev/null | awk -F= '
			/^ID_BUS=/ {bus=$2}
			/^ID_MODEL=/ {model=$2}
			/^ID_VENDOR=/ {vendor=$2}
			/^ID_SERIAL_SHORT=/ {serial=$2}
			END {printf "%s %s %s %s\n", bus, model, vendor, serial}'
	)

	# Fallback: guess kind if udevadm didn't return info
	if [ -z "$bus" ]; then
		case "$dev" in
			mmcblk*) devKind="SD/MMC" ;;
			sd*)     devKind="Unknown" ;;
			*)       devKind="Unknown" ;;
		esac
	else
		devKind="$bus"
	fi

	# Format output
	printf '%s%s%s%s' "$devKind" \
		${model:+ ", $model"} \
		${vendor:+ ", $vendor"} \
		${serial:+ ", $serial"}
}

# Cleanup function: unmount and remove mountpoint if still mounted
caught() {
	if [ ! -z ${trgMntGlobal+X} ]; then
		if mountpoint -q "$trgMntGlobal"; then
			umount "$trgMntGlobal" && rmdir "$trgMntGlobal"
			log "Unmounted and removed $trgMntGlobal"
		fi
	fi
}

# Mount the target partition by PARTUUID, read-only if dry-run
mountTrg() {
	local trgUuid="$1"
	local isDryRun="${2:-0}"
	mnt="${tmpMntBase}-${trgUuid}"
	mkdir -p "$mnt"
	local dev
	dev="$(blkid -t PARTUUID="$trgUuid" -o device 2>/dev/null || true)"
	[ -n "$dev" ] || die "Cannot find device for PARTUUID $trgUuid"

	local opts="rw"
	[ "$isDryRun" -eq 1 ] && opts="ro"
	mount -o "$opts" "$dev" "$mnt"
	log "Mounted $dev on $mnt with option $opts"

	echo "$mnt"
}

# Record approved parameters to a file in the user's home directory
writeParamFile() {
	local srcUuid="$1" trgUuid="$2" dryRun="$3";shift 3
	local pf="${paramDir}/.${progNam}.${srcUuid}.${trgUuid}.${dryRun}.params"
	local opts="$*"
	{
		printf '%s\n' "$opts"
		printf '# Approved: %s\n' "$(date --iso-8601=seconds)"
		printf '# Source: %s (PARTUUID=%s)\n' "$srcDevInfo" "$srcUuid"
		printf '# Target: %s (PARTUUID=%s)\n' "$trgDevInfo" "$trgUuid"
	} > "$pf"
	chmod 600 "$pf"
	log "Wrote param file $pf"
}

# Check if parameters have been approved (approval file exists)
checkParamFileApproved() {
	local srcUuid="$1" trgUuid="$2" dryRun="$3"
	local pf="${paramDir}/.${progNam}.${srcUuid}.${trgUuid}.${dryRun}.params"
	[ -f "$pf" ] && return 0 || return 1
}

# Run rsync with the chosen options to perform the backup
doRsync() {
	[ "$(readlink -f "$trgMntGlobal")" != "/" ] || die "Target mountpoint resolves to /"
	mountpoint -q "$trgMntGlobal" || die "Target is not mounted"
	command -v rsync >/dev/null 2>&1 || die "rsync not found"
	log "Starting rsync to $trgMntGlobal"
	rsync "${rsyncOpts[@]}" "${rsyncExcl[@]}" / "$trgMntGlobal"/
	local rc=$?
	[ $rc -eq 0 ] || die "rsync exited with code $rc"
	log "rsync finished successfully"
}

# Main program logic
main() {
	local arg dryRun=0
	local -a rsyncOptsPassed=()

	trap 'caught' EXIT

	# Parse command-line arguments
	for arg in "$@"; do
		case "$arg" in
			--dry-run) dryRun=1; rsyncOpts+=(--dry-run);;
			-h|--help) showHelp; exit 0 ;;
			--) rsyncOptsPassed+=${arg} ;;
			*)
				if [ ${#rsyncOptsPassed[@]} = 0 ]; then 
					showHelp "Unknown option: $arg"; exit 1
				else
					if [ ${rsyncOptsPassed[0]} = "--" ]; then 
						rsyncOptsPassed[0]=${arg} # Replace -- with arg
					else
						rsyncOptsPassed+=(${arg}) # add arg
					fi
				fi
				;;
		esac
	done
	if [ ${#rsyncOptsPassed[@]} -gt 0 ]; then
    rsyncOpts+=("${rsyncOptsPassed[@]}")
	fi

	# Re-exec as root if not already root
	if [ "$(id -u)" -ne 0 ]; then
		exec sudo "$0" "$@"
	fi

	local srcUuid trgUuid srcDev trgDev srcDevInfo trgDevInfo
	srcUuid="$(getSrcUuid)"
	trgUuid="$(getTrgUuid "$srcUuid")"

	srcDev=$(findmnt -n -o SOURCE /)
	trgDev=$(blkid -t PARTUUID="$trgUuid" -o device)
	srcDevInfo=$(getDevInfo "$srcDev")
	trgDevInfo=$(getDevInfo "$trgDev")

	local isTty=0; [ -t 1 ] && isTty=1
	[ -r rbnotty ] && isTty=0 # hack to test batch interactively

	if [ "$isTty" -eq 0 ]; then
		checkParamFileApproved "$srcUuid" "$trgUuid" "$dryRun" || die "Cron run blocked: no approval"
		local paramLine
		paramLine=$(head -n1 "${paramDir}/.${progNam}.${srcUuid}.${trgUuid}.${dryRun}.params" || echo "")
		 if [[ "${paramLine}" != "${@}" ]]; then
		 	log "Not approved options:     ${@}"
			log "Approved would have been: ${paramLine}"
			die "Unapproved options in batch mode"
		fi
		log "Non-interactive run authorized"
	else
		echO "Source: ${srcDev} (${srcDevInfo}, PARTUUID=${srcUuid})"
		echO "Target: ${trgDev} (${trgDevInfo}, PARTUUID=${trgUuid})"
		local ans
		read -r -p "Your choice (run/approve/quit) [r/a/q]: " ans >&2
		case "${ans:0:1}" in
			r)
				# doRsync will run later
				;;
			a)
				writeParamFile "$srcUuid" "$trgUuid" "$dryRun" "$@"
				echO "Approved for cron only."
				log "User approved for next cron (options: $@)"
				return 0
				;;
			q)
				log "User quit without running"
				exit 0
				;;
			*)
				die "Invalid choice"
				;;
		esac
	fi

	# Capacity check (skipped for dry-run); exit on failure
	[ "$dryRun" -eq 0 ] && checkTargetCapacity "$trgDev"
	trgMntGlobal=$(mountTrg "$trgUuid" "$dryRun")
	# Above should return a mountpoint (which
	# exists) but can return eror text, in
	# that case we need to exit
	[ -e $trgMntGlobal ] || (echo "ERROR: mount returned \"$trgMntGlobal\" instead of a mount point";exit 33)

	doRsync
	log "rbackup $@ completed successfully"
	[ "$isTty" -eq 1 ] && echO "rbackup: completed successfully"
}

main "$@"
