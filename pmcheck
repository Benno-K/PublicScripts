#!/usr/bin/env perl
use strict;
use warnings;
use File::Find;
use Getopt::Long;
use Time::HiRes qw(time);
use Module::Metadata;
use Module::CoreList;

# -----------------------------------------------------------
# pmcheck - Perl Module Checker
# Created by ChatGPT, designed by the author
#
# Purpose:
#   Check Perl scripts in $PATH, detect missing modules,
#   suggest apt packages, and list CPAN-only modules.
#
# Features:
#   - Recursive dependency checking
#   - Verbose mode (-v) showing each module checked
#   - Statistics mode (-s #) showing progress every # modules
#   - Outputs a single "apt install ..." line for missing Debian-packaged modules
#   - Writes CPAN-only missing modules to a file (cpan-missing.txt)
#   - Explain mode (--explain) shows which scripts require which missing modules
#     and counts of missing modules per script
#   - Help info via -h or --help
#   - Summary report at end: scripts, top-level modules, recursive modules
#   - Hidden -X # option to stop after # modules (for testing)
#   - Tracks and reports total runtime
# -----------------------------------------------------------

my $verbose       = 0;
my $statInterval  = 0;
my $maxModules    = 0;
my $help          = 0;
my $explain       = 0;

GetOptions(
    "v"        => \$verbose,
    "s=i"      => \$statInterval,
    "X=i"      => \$maxModules,
    "h|help"   => \$help,
    "explain"  => \$explain,
) or die "Error parsing options\n";

if ($help) {
    print <<"USAGE";
Usage: pmcheck [options]

Options:
  -v              Verbose output (print each module as it is checked)
  -s <N>          Show statistics every N modules
  --explain       Show which scripts require which missing modules
  -h, --help      Show this help message

Debug/testing:
  -X <N>          Stop after checking N modules (for faster testing)
USAGE
    exit;
}

my $startTime = time();

# -----------------------------------------------------------
# Hashes to track modules and usage
# -----------------------------------------------------------
my %checkedModules;
my %missingModules;
my %moduleUsage;       # module -> [ scripts that required it ]
my %aptPackages;
my %scriptsSeen;

# -----------------------------------------------------------
# Helpers
# -----------------------------------------------------------
sub normalizeModuleName {
    my ($name) = @_;
    return undef unless defined $name;

    $name =~ s/^\s+|\s+$//g;
    $name =~ s/['"]//g;

    return undef if $name =~ /^(main|MM|MY|v5|U64|inc::latest)$/;
    return undef if $name =~ /^[a-z]+$/;

    $name =~ s/^(.*?::.*?)(::.*)?$/$1/;
    return $name;
}

sub isCoreModule {
    my ($module) = @_;
    return exists $Module::CoreList::version{$module};
}

sub moduleToApt {
    my ($module) = @_;
    my $pkg = lc($module);
    $pkg =~ s/::/-/g;
    return "lib$pkg-perl";
}

sub checkModule {
    my ($module, $originScript, $processedCount) = @_;
    return if $checkedModules{$module}++;

    $moduleUsage{$module} ||= [];
    push @{$moduleUsage{$module}}, $originScript if $originScript;

    print "Checking module: $module\n" if $verbose;

    $module =~ s/^\s+|\s+$//g;
    $module =~ s/['"]//g;

    return if isCoreModule($module);

    eval {
        local $^W = 0;
        require $module;
    };

    if ($@) {
        $missingModules{$module} = 1;
        $aptPackages{ moduleToApt($module) } = 1;
    }

    if ($statInterval && $processedCount % $statInterval == 0) {
        my $elapsed = time() - $startTime;
        printf "Processed %d modules in %.1f seconds\n", $processedCount, $elapsed;
    }
}

# -----------------------------------------------------------
# Find Perl scripts in PATH
# -----------------------------------------------------------
my @pathDirs = split /:/, $ENV{PATH};
my @perlScripts;

for my $dir (@pathDirs) {
    next unless -d $dir;
    find(
        sub {
            return unless -f $_ && -x _;
            open my $fh, '<', $_ or return;
            my $first = <$fh>;
            close $fh;
            push @perlScripts, $File::Find::name
              if defined $first && $first =~ m{^#!.*perl};
        },
        $dir
    );
}

# -----------------------------------------------------------
# Scan scripts for "use" and "require"
# -----------------------------------------------------------
my @allModules;
for my $script (@perlScripts) {
    $scriptsSeen{$script} = 1;
    open my $fh, '<', $script or next;
    while (<$fh>) {
        if (/^\s*use\s+([\w:]+)/ || /^\s*require\s+([\w:']+)/) {
            my $mod = $1;
            $mod =~ s/['"]//g;
            push @allModules, [$mod, $script];
        }
    }
    close $fh;
}

# -----------------------------------------------------------
# Process modules
# -----------------------------------------------------------
my $processed = 0;
for my $pair (@allModules) {
    my ($mod, $src) = @$pair;
    checkModule($mod, $src, ++$processed);
    last if $maxModules && $processed >= $maxModules;
}

# -----------------------------------------------------------
# Summarize
# -----------------------------------------------------------
my $runtime = time() - $startTime;

my %collapsedMissing;
for my $m (keys %missingModules) {
    my $norm = normalizeModuleName($m);
    $collapsedMissing{$norm} = 1 if $norm;
}

print "\n===== Summary =====\n";
printf "Total Perl scripts scanned (from PATH): %d\n", scalar keys %scriptsSeen;
printf "Total top-level modules referenced by scripts: %d\n", scalar @allModules;
printf "Total modules checked recursively: %d\n", $processed;
printf "APT-installable missing modules (raw): %d\n", scalar keys %aptPackages;
printf "Unique top-level missing modules: %d\n", scalar keys %collapsedMissing;

# Write apt install file
open my $aptfh, '>', 'apt-install-missing.txt' or die $!;
print $aptfh join(" ", sort keys %aptPackages), "\n";
close $aptfh;

if (%aptPackages) {
    print "APT install command:\n  sudo apt install ", join(" ", sort keys %aptPackages), "\n";
}
print "APT install command saved to apt-install-missing.txt\n";

# Write CPAN-only missing file
open my $cpanfh, '>', 'cpan-missing.txt' or die $!;
for my $m (sort keys %collapsedMissing) {
    my $apt = moduleToApt($m);
    print $cpanfh "$m\n" unless exists $aptPackages{$apt};
}
close $cpanfh;
print "CPAN-only missing modules saved to cpan-missing.txt\n";

printf "Total runtime: %.1f seconds\n", $runtime;
print "===================\n";

# -----------------------------------------------------------
# Explain mode with per-script counts
# -----------------------------------------------------------
if ($explain) {
    print "\n===== Missing Modules with Script Context =====\n";
    open my $fh, '>', 'missing-details.txt' or die "Can't write missing-details.txt: $!";

    my %scriptMissing;
    foreach my $module (sort keys %collapsedMissing) {
        for my $script (@{ $moduleUsage{$module} // [] }) {
            push @{ $scriptMissing{$script} }, $module;
        }
    }

    foreach my $script (sort keys %scriptMissing) {
        my @mods = @{ $scriptMissing{$script} };
        printf "Script: %s (%d missing modules)\n", $script, scalar @mods;
        for my $mod (@mods) {
            print "  $mod\n";
        }
        print "\n";
        print $fh "Script: $script (" . scalar(@mods) . " missing modules)\n";
        print $fh join("\n", map { "  $_" } @mods) . "\n\n";
    }

    close $fh;
    print "Details also written to missing-details.txt\n";
    print "===============================================\n";
}
