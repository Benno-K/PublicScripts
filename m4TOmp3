#!/bin/bash

# Convert audiobooks (m4b created from Audible
# files using libation) into MP3 having
# shorter names and titles (preserving the
# cover). Target is the Music directory of
# an Intenso VideoScooter BT player.
##
##

while [ ${1:0:1} = "-" ]
do
	case $1 in
		-dry)
			dry=on
			;;
		-debug|-dbg|-d)
			debug=on
			;;
		*)
			echo >&2 "Illegal option: $1"
			exit 1
			;;
	esac
	shift
done
if [ $# != 2 ]; then
	cat <<-EOI
	Usage: ${0/*\/} [input-dir] [output-dir]
	  where
	    input-dir contains .m4b-files
	  and
	    output-dir will contain the .mp3 files
	EOI
	exit 2
fi

# Function to process a single file
# Args: #1	input file
#       #2	output directory
#       #3	output filename
m4bProcess () {
		local infil="$1"
		local outdir="$2"
		local outnam="$3"
		local qffmpeg="ffmpeg -loglevel error -hide_banner -nostats"
		local output="${outdir}/${outnam/\.m4[ab]}.mp3"
		if [ ! -z "${outdir}" ]; then
			mkdir -p "${outdir}"
		fi
		cover=$(mktemp -u coverXXXXX.jpg)

		# Extract source bitrate
		if [ -z "$dry" ]; then
			bitrate=$(ffprobe -v quiet -show_entries format=bit_rate -of default=nw=1 "$infil" | sed 's/[^0-9]*//g')
			bitrate_k=$((bitrate / 1000))
		else
			bitrate_k=$((128))
		fi

		# Limit to max. MP3 if higher
		if [ "$bitrate_k" -gt 320 ]; then
			bitrate_k=320
		fi

		# Extract cover (if existing)
		[ -z "$dry" ] && $qffmpeg -i "$infil" -map 0:v -c copy $cover -y > /dev/null 2>&1

		# Convert to MP3 (same bitrate) and add
		# tags and (if exists) cover - otherwise
		# only tags
		if [ -f $cover ]; then
			[ -z "$dry" ] && $qffmpeg \
				-i "$infil" \
				-i $cover \
				-c:a libmp3lame \
				-b:a "${bitrate_k}k" \
				-id3v2_version 3 \
				-map 0:a \
				-map 1:v \
				-metadata title="${mp3tag[title]}" \
				-metadata album="${mp3tag[album]}" \
				-metadata track="${mp3tag[track]}" \
				-metadata:s:v title="Album cover" \
				-metadata:s:v comment="Cover (front)" \
				"$output" -y
			rm $cover
		else
			[ -z "$dry" ] && $qffmpeg \
				-i "$infil" \
				-c:a libmp3lame \
				-b:a "${bitrate_k}k" \
				-id3v2_version 3 \
				"$output" -y
		fi
		# Return the product (filespec) of our
		# efforts
		echo "$output"
}

# Arguments MUST be passed to this script
#   #1	directory containing m4b- (or m4a)
#     	files
inDir=$1

# which file-extension will be searched
filExt=m4b

# Make sure that shell's file globbing returns
# an empty string (instead of the pattern) if
# no match
shopt -s nullglob

# For all files ending with filExt
for input in "$inDir"/*.${filExt}; do
	# This error handling should never
	# trigger, but if we should terminate
	if [ ! -e "${input}" ]; then
		echo "error searching ${input}"
		echo "input file does not exist"
		exit 4
	fi
	# Need an associative array
	declare -A tag
	# What trick this is:
	#  1. use ffprobe to extract all the tags
	#     in json-format
	#  2. use jq to get key=value line
	#  3. read that input a populate the
	#     tag array with that data
	#  Here we go, this is step 3 taking
	#  the input from step 2 which was retrieved
	#  using step 1. Use FD 20 to avoid troubles
	#  with other reads (from stdin = FD0)
	while IFS='=' read -r key value <&20; do
			tag["$key"]="$value"
	done 20< <(
			ffprobe -v quiet -show_format -print_format json "$input" | jq -r '.format.tags | to_entries[] | "\(.key)=\(.value)"'
	)

	# Get track info, get current and max track
	trackInfo=${tag[track]}
	curTrk=${trackInfo//\/*}
	maxTrk=${trackInfo//*\/}
	# For the filename the track no. should have
	# leading zeros (how much depends on the
	# highest track no.)
	read chap < <(printf "%0${#maxTrk}d\n" $curTrk)
	# Handle shortening of different titles
	if [[ "${tag[title]}" =~ "Madame le Commissaire" ]]; then
		stitle=${tag[title]%*:* Kapitel*}
	elif [[ "${tag[album]}" =~ "The Cuckoo's Egg" ]]; then
		stitle="Cuckoo's Egg"
	elif [ "${tag[album]}" = "Kluftinger" ]; then
		stitle=${tag[title]/:*}
	else
		stitle=${tag[title]%*:* Kapitel*}
	fi
	# Build output directory name
	dirnam=${stitle//$curTrk - /}
	# use it as title-tag as well
	ftitle=$dirnam
	# shorten to MlC
	#  without part
	stitle="${dirnam//Madame le Commissaire /MlC }"
	#  with part
	vstitle="${dirnam//Madame le Commissaire /MlC${tag[PART]} }"
	# Title still too long? Then shorten
	# by using first and last word
	first=${vstitle%% *}
	last=${vstitle##* }
	[ ${#vstitle} -gt 30 ] && dirnam="$first -- $last"||dirnam=${stitle}
	# Short filename
	filnam="${chap}. Kapitel"
	# Define Mp3 tags to be written
	declare -A mp3tag
	mp3tag[album]=$ftitle
	mp3tag[title]=$filnam
	mp3tag[track]=$curTrk
	# Debug output
	[ ! -z "$debug" ] && cat <<-EOI
	album:    ${tag[album]}
	title:    ${ftitle}
	subtitle: ${tag[SUBTITLE]}
	series:   ${tag[SERIES]}
	part:     ${tag[PART]}
	track:    $curTrk ($chap)
	file: "$2${dirnam}/${filnam}"
	EOI
	# Show what we are working on
	echo ${dirnam}/${filnam}
	mp3fil=$(m4bProcess "$input" "$2/${dirnam}" "${filnam}")
	# and the outcome
	echo "  -> ${mp3fil}" >&2
done
